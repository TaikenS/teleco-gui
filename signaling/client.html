<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>WebRTC Audio Receiver (WebSocket Signaling)</title>
    <style>
      body {
        font-family: sans-serif;
        padding: 16px;
      }
      button {
        margin-right: 8px;
        margin-top: 8px;
      }
      input {
        width: 520px;
      }
      .hint {
        color: #555;
        font-size: 12px;
      }
      pre {
        background: #f6f6f6;
        padding: 8px;
        overflow: auto;
        height: 240px;
      }
      code {
        background: #f2f2f2;
        padding: 2px 4px;
      }
    </style>
  </head>
  <body>
    <h2>WebRTC音声 受信（WebSocketシグナリング / teleco-gui互換label）</h2>

    <div>
      <div>WS URL:</div>
      <input id="wsUrl" />
      <div class="hint">例: <code>ws://localhost:8080/?room=test</code></div>
    </div>

    <div>
      <button id="connect">Connect WS</button>
      <button id="disconnect" disabled>Disconnect</button>
      <button id="enableAudio">Enable Audio</button>
      <button id="hangup" disabled>Hangup</button>
    </div>

    <p>状態: <span id="status">idle</span></p>

    <h3>Remote Audio</h3>
    <audio id="remoteAudio" autoplay controls></audio>

    <h3>Log</h3>
    <pre id="log"></pre>

    <script>
      const $ = (id) => document.getElementById(id);

      const wsUrlInput = $("wsUrl");
      const connectBtn = $("connect");
      const disconnectBtn = $("disconnect");
      const enableAudioBtn = $("enableAudio");
      const hangupBtn = $("hangup");
      const statusEl = $("status");
      const remoteAudio = $("remoteAudio");
      const logEl = $("log");

      // http://localhost:8080/client.html?room=test で開く想定
      const room = new URL(location.href).searchParams.get("room") || "default";
      wsUrlInput.value = `ws://${location.host}/?room=${encodeURIComponent(room)}`;

      let ws = null;
      let pc = null;

      // teleco-gui から受けたコール情報（返信時に付与）
      let currentCallToken = null;
      let currentDestination = null;

      function setStatus(s) {
        statusEl.textContent = s;
      }

      function log(...args) {
        const line = args
          .map((a) => {
            try {
              return typeof a === "string" ? a : JSON.stringify(a);
            } catch {
              return String(a);
            }
          })
          .join(" ");
        logEl.textContent += line + "\n";
        logEl.scrollTop = logEl.scrollHeight;
        console.log(...args);
      }

      function send(msg) {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        ws.send(JSON.stringify(msg));
        log("SIGNAL OUT:", msg);
      }

      async function ensurePC() {
        if (pc) return;

        pc = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
        });

        // 受信側で生成したICEは teleco-gui 側へ返す（teleco-guiは audioIceCandidateresponse を待つ）
        pc.onicecandidate = (e) => {
          if (!e.candidate) return;
          if (!currentCallToken) return; // offer未受信の段階では送らない

          send({
            label: "audioIceCandidateresponse",
            destination: currentDestination ?? "",
            id_call_token: currentCallToken,
            candidate: e.candidate.toJSON ? e.candidate.toJSON() : e.candidate,
          });
        };

        pc.ontrack = (e) => {
          log("ONTRACK fired", {
            kind: e.track.kind,
            streams: !!(e.streams && e.streams[0]),
            muted: e.track.muted,
            enabled: e.track.enabled,
            readyState: e.track.readyState,
          });

          const ms =
            e.streams && e.streams[0]
              ? e.streams[0]
              : new MediaStream([e.track]);
          remoteAudio.srcObject = ms;

          // 自動再生制限対策：失敗理由をログに出す
          remoteAudio
            .play()
            .catch((err) => log("play blocked:", err?.message || err));
        };

        pc.onconnectionstatechange = () => {
          log("pc connectionState:", pc.connectionState);
          setStatus(`pc: ${pc.connectionState}`);
        };

        pc.oniceconnectionstatechange = () => {
          log("pc iceConnectionState:", pc.iceConnectionState);
        };
      }

      async function handleSignal(msg) {
        // Offer（teleco-gui -> receiver）
        if (msg.label === "callAudioRequest") {
          log("SIGNAL IN: callAudioRequest (offer)");

          // 二重Offer対策：既存PCを破棄して作り直す
          if (pc) {
            try {
              pc.close();
            } catch {}
            pc = null;
          }

          currentCallToken = msg.id_call_token ?? null;
          currentDestination = msg.destination ?? null;

          await ensurePC();

          try {
            await pc.setRemoteDescription(msg.sdp);
          } catch (e) {
            log("ERROR setRemoteDescription(offer):", e?.message || e);
            return;
          }

          let answer;
          try {
            answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
          } catch (e) {
            log("ERROR create/setLocalDescription(answer):", e?.message || e);
            return;
          }

          // Answer（receiver -> teleco-gui）
          send({
            label: "callAudioAnswer",
            destination: msg.destination,
            id_call_token: msg.id_call_token,
            sdp: answer,
          });

          hangupBtn.disabled = false;
          return;
        }

        // ICE（teleco-gui -> receiver）
        if (msg.label === "audioIceCandidaterequest") {
          await ensurePC();

          // token/destination をまだ知らないケースに備える
          if (!currentCallToken && msg.id_call_token)
            currentCallToken = msg.id_call_token;
          if (!currentDestination && msg.destination)
            currentDestination = msg.destination;

          try {
            await pc.addIceCandidate(msg.candidate);
          } catch (e) {
            log("ERROR addIceCandidate(request):", e?.message || e);
          }
          return;
        }

        // それ以外は無視
        log("IGNORED SIGNAL:", msg);
      }

      function cleanup(keepWs = true) {
        if (remoteAudio.srcObject) remoteAudio.srcObject = null;

        if (pc) {
          try {
            pc.close();
          } catch {}
          pc = null;
        }

        currentCallToken = null;
        currentDestination = null;

        hangupBtn.disabled = true;

        if (keepWs && ws && ws.readyState === WebSocket.OPEN)
          setStatus("ws connected");
        else setStatus("idle");
      }

      enableAudioBtn.onclick = async () => {
        try {
          await remoteAudio.play();
          log("Audio enabled by user gesture");
        } catch (e) {
          log("enableAudio failed:", e?.message || e);
        }
      };

      connectBtn.onclick = () => {
        setStatus("ws connecting...");
        logEl.textContent = "";

        ws = new WebSocket(wsUrlInput.value);

        // 文字列で来る想定（server.js側で文字列化して中継している）
        ws.onopen = () => {
          setStatus("ws connected");
          log("WS OPEN");
          connectBtn.disabled = true;
          disconnectBtn.disabled = false;
        };

        ws.onmessage = async (ev) => {
          try {
            const text =
              typeof ev.data === "string" ? ev.data : String(ev.data);
            const msg = JSON.parse(text);
            log("SIGNAL IN:", msg);
            await handleSignal(msg);
          } catch (e) {
            log("ERROR JSON parse:", e?.message || e);
          }
        };

        ws.onclose = () => {
          log("WS CLOSE");
          setStatus("ws closed");
          connectBtn.disabled = false;
          disconnectBtn.disabled = true;
          cleanup(false);
        };

        ws.onerror = () => {
          log("WS ERROR");
          setStatus("ws error");
        };
      };

      disconnectBtn.onclick = () => {
        if (ws) {
          ws.close();
          ws = null;
        }
      };

      hangupBtn.onclick = () => {
        cleanup(true);
      };
    </script>
  </body>
</html>
